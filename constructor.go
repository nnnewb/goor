package main

import (
	"bytes"
	"go/format"
	"log"
	"strings"
	"text/template"

	"github.com/iancoleman/strcase"
	"golang.org/x/tools/go/packages"
)

// createConstructor creates the contents of a constructor and converts them into bytes.
func createConstructor(pkg *packages.Package, fields []field) ([]byte, error) {
	type templateInfo struct {
		StructName string
		Fields     []field
		Pointer    bool
	}

	body := new(bytes.Buffer)

	if err := template.Must(template.New("body").Funcs(map[string]interface{}{
		"ToLowerCamel": strcase.ToLowerCamel,
		"ToCamel":      strcase.ToCamel,
	}).Parse(`
	func New{{ ToCamel .StructName }}(
							{{- range .Fields }}
								{{- if eq .ConstructorIgnore false}}
									{{ ToLowerCamel .FieldName }} {{ .FieldType }},
								{{- end }}
							{{- end }}
						) {{ if .Pointer }}*{{ end }}{{ .StructName }} {
							return {{ if .Pointer }}&{{ end }}{{ .StructName }}{
								{{- range .Fields }}
									{{- if eq .ConstructorIgnore false}}
										{{ .FieldName }}:{{ ToLowerCamel .FieldName }},
									{{- end }}
								{{- end }}
							}
						}
					`)).Execute(body, templateInfo{
		StructName: *typeName,
		Fields:     fields,
		Pointer:    *pointer,
	}); err != nil {
		return nil, err
	}

	out := new(bytes.Buffer)
	if err := template.Must(template.New("out").Parse(`
			// Code generated by {{ .CmdName }}; DO NOT EDIT.
			package {{ .PackageName }}

			{{ .PkgImport }}

			{{ .Body }}

			{{ .GetterSetter }}
		`)).Execute(out, map[string]string{
		"CmdName":      cliName,
		"PackageName":  pkg.Name,
		"PkgImport":    createPkgImport(pkg, fields),
		"Body":         body.String(),
		"GetterSetter": createGetterSetter(fields),
	}); err != nil {
		return nil, err
	}

	return format.Source(out.Bytes())
}

// createGetterSetter generate the contents of a getter setter
func createGetterSetter(fields []field) string {
	type templateInfo struct {
		TypeName string
		Fields   []field
		Getter   bool
		Setter   bool
	}

	out := new(bytes.Buffer)

	if err := template.Must(template.New("getter").Funcs(map[string]interface{}{
		"ToCamel": strcase.ToCamel,
	}).Parse(`
	{{- if eq .Getter true}}
		{{- range .Fields }}
			{{- if eq .GetterIgnore false}}
				func (g *{{ $.TypeName }}) {{ ToCamel .FieldName }}() {{ .FieldType }} {
				return g.{{ .FieldName }}
				} 
			{{- end }}
		{{ end }}		
	{{- end }}

	{{- if eq .Setter true}}
		{{- range .Fields }}
			{{- if eq .SetterIgnore false}}
					func (s *{{ $.TypeName }}) Set{{ ToCamel .FieldName }}({{ .FieldName }} {{ .FieldType }}) {
						s.{{ .FieldName }} = {{ .FieldName }}
					} 
			{{- end }}
		{{ end }}
	{{- end }}
	`)).Execute(out, &templateInfo{
		TypeName: *typeName,
		Fields:   fields,
		Getter:   *getter,
		Setter:   *setter,
	}); err != nil {
		log.Fatalf("create getter setter err:%v", err)
	}

	return out.String()
}

// createPkgImport generate an import
func createPkgImport(pkg *packages.Package, fields []field) string {
	var pkgImports []string

	for _, p := range pkg.Imports {
		for _, f := range fields {
			if !f.ConstructorIgnore && strings.Contains(f.FieldType, p.Name) {
				pkgImports = append(pkgImports, p.PkgPath)
			}

			if *getter && !f.GetterIgnore && strings.Contains(f.FieldType, p.Name) {
				pkgImports = append(pkgImports, p.PkgPath)
			}

			if *setter && !f.SetterIgnore && strings.Contains(f.FieldType, p.Name) {
				pkgImports = append(pkgImports, p.PkgPath)
			}
		}
	}

	// if the import does not exist
	if len(pkgImports) == 0 {
		return ""
	}

	out := new(bytes.Buffer)
	if err := template.Must(template.New("out").Parse(`
			import(
				{{- range . }}
					"{{ . }}"
				{{- end }}
			)
		`)).Execute(out, pkgImports); err != nil {
		log.Fatal(err)
	}

	return out.String()
}
